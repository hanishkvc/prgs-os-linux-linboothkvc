Readme - linboothkvc
v16Jan2012_2204
HKVC, GPL
A linux kernel module based bootstrap loader
----------------------------------------------

>> 16Jan2012_2154 <<
:-) SUCCESS ON a Actual HARDWARE :-) (not _the_ h/w yet ;-)

For Arm Cortex_A8 based SOCs (tried with Dm3730)
Hopefully similar conclusion should work for Omap4 successfully, except for any
unknown (to me currently) SMP issues, inspite of me shutting down the 2nd processor.
------------------------------------------------------------------------------
After further experimentations, digging thro docs and frustrations, have finally
realised that MVA based Cache maintainance operations aren't sufficient for
flushing updated data from Cache to Memory, because the POU or POC in many cases
terminates at L2 or some other Cache level rather than Memory.

Now MVA based cache flush operations are fine for normal linux kernel operations,
but for getting into a Nirvana (new prestine execution environment) setup with
caches disabled, this is not good enough as the changes don't hit the memory.

Leave linboothkvc related memory operations for Nirvana or NChild code aside,
Rather even the kernel module loaders symbol resolution updates to the
kernel module code also doesn't get saved to memory - because even it uses
flush_icache_range which inturn uses v7_coherent_kern_range which inturn
uses MVA based cache flush operations.

So in conclusion we require a cache flush logic which uses set/way based cache
maintainance operation and inturn walks thro all the cache heirarchy levels.
In turn the flush_kern_all provides the required operation to achieve the same.

Currenlty I am using my understanding of Omap3 bootrom code based on the dump
of the same in qemu-linaro as well as on Dm3730 using openocd and xds100v2
to jump to the new bootloader (i.e NChild, which is x-loader currently) from
Nirvana code. So this will work with BeagleXM. However for NookTab, I have
to look at Omap4 bootrom, for which I haven't looked at jtag access currently.

But once I have setup the proper Nirvana code for NookTab, the logic should
work 99% on it, as my finding/understanding of Cache issue which I faced
seems to indicate the same unless SMP adds some additional complexity, which
seems less likely currently to me.

NOTE: TOCHECK_LATER: If I put a busy loop in the Nirvana Code of sufficiently
long duration then the system seems to go haywire and abort, may be some
watchdog timer is trying to kick in or ?????, have to debug later.

NOTE: In ARM Clean cache means flush the data from Cache to next cache level
or memory and Invalidate cache means make the given cache line entry invalid,
so that a fresh access to the address will force a read from the next cache
level or memory.

>> 16Jan2012_0138 <<

There is a VA-to-PA translation instruction provided by ARM CP15 system
coprocessor.

There is simple sys and msr and mrs (if I remember names correctly) instructions
available instead of mcr and mrc instrcutions

The swi has been renamed svc

For cache and if required TLB flushing MVA based instructions of CP15 will
be the simplest (i.e where the MemoryVirtualAddress is provided).

NOTE: Till date the issues I have found, yet to resolve have been related
to Cache flushing (is it called invalidate or clean or ... in Arm) and
not affected by TLB.

Have to check the relation between TLB and PageTables and Hardwired and
Software controlled in ARM in depth later.

>> 15Jan2012 <<

The issue with disabling mmu with in kernel module not working in last release
has been fixed.

The actual bug was that I had wrongly used mrc after bic instead of mcr. However
it actually wouldn't have worked for 100% in beaglexm, because kernel modules
get loaded into a virtual address around 0xbf00.0000, which is well beyond the
physical memory address available (i.e with actual DRAM) in beaglexm (which is
only 512MB i.e 0x8000.0000+512MB) so setup-mm-for-reset/reboot wouldn't have
set a 1-to-1 (s-to-s) map for this virtual address and once mmu gets disabled
the processor would have messed up with a exception/????

So for now it is only safe to disable mmu from within Nirvana code, and not
from with in kernel module code. And the nirvana code omap3callbootrom1.S
already takes care of this mmu disable properly.

Also found that Bkpt instruction doesn't work between qemu and gdb with target
remote combination. Haven't checked with openocd+gdb and actual h/w yet.

>> 15Jan2012 <<

Have completed the qemu beaglexm based linboothkvc (kexec) FULLY Now. Now from
with in a running linux system in qemu, you can restart a new linux kernel and its
user space.

For this currently it uses the x-loader itself to bootstrap u-boot.bin and inturn
the linux kernel, similar to how the hardware bootrom does it on power on. This
new x-load.bin image is embedded within the kernel module.

I have updated the kernel module such that it takes 2 images into itself.

Image 1 == The Nirvana Code (Example - bloop?.S, omap3callbootrom1.S, ...)
This gets passed the control once the kernel module is done with disabling interrupts,
disabling mmu (something seems to be missing wrt this with the latest changes I did
to accomodate Nirvana and Nirvana's child, have to debug later), setting up the
1 to 1 mmu map, etc.

In turn currently the nirvana code omap3callbootrom1.S takes care of disabling mmu,
interrupts etc once again just to be safe. And inturn it loads the NirvanaChild code
into 0x4020.0800 similar to how Omap3 bootrom loader does its job, and inturn calls
the entry point at 0x4001.4000 in the bootrom. This takes care of setting up the
stack and calling the NirvanaChild Code.

Image 2 == The NirvanaChild Code (Example - x-load.bin (without signGP))
The address and length of this code is passed to Nirvana Code thro r0 and r1
respectively. It is upto Nirvana code to decide what it will do with this image.

As of today only the omap3callbootrom1.S nirvana code handles this image as required
while the older nirvana codes don't know about this.

NOTE: misc/Binaries/HKVC-x-load.bin - Currently the new x-load.bin is expected to be
with in misc/Binaries/HKVC-x-load.bin in the linboothkvc subfolder.

If you want to experiment with a new x-loader or any other bootloader, then copy it
to above mentioned location and then run the following.

./hkvc-make clean
./hkvc-make nchild
./hkvc-make asm
./hkvc-make

OR if you only want to recompile the kernel module for your running kernel on qemu

./hkvc-make

Next copy the lbhkvc_km_DEVICE_BEAGLEXM.ko to qemu running linux (for which you
compiled the kernel module). and insmod the kernel module and see the magic :-)

>> 14Jan2012 <<

Step1 [DONE]: Basic logic working in QEmu BeagleboardXM correctly now. Becaue Qemu doesn't
similate Cache fully the bug related cache handling doesn't affect it. Qemu based snooping
allowd me to identify my stupid mistake of not setting flags in my nirvana code samples.
Also it helped me to run thro the boot flow as well as few other aspects of the shutdown
process fully like identifying the MMU wasn't disabled by the kernel support routine
(Now come on who wants to read thro the code carefully to identify these same, when one can
experiment with the flow in qemu (lazzy me) :-) among others. My only peeve with Qemu
is the way it maps the serial port to stdio or ptys rather indirectly arbitrarily to some
extent.


Step2 [Next]: Next have to fix my known bugs and try on actual BeagleboardXM, now that
I have got hold of xds100v2 yesterday and inturn able to debug Beagle using openocd.
Rather put the required asm code directly instead of calling the hidden kernel functions.

Step3 [After]: With the above two, most probably the code should run straight on Nook also
as I have already taken care of shutting the 2nd proc down. Any additional SMP sync logic
if any in chip to be looked at beyond the ISB and DSB syncing wrt current cpu.

NOTE: jtag access as allowed me to confirm my suspisions wrt cache


>> 08+Jan2012 <<
Moving away from directly trying on NookTab to experiment with qemu initially to help
debug the code easily (instead of requiring to experiment with uart prints).


Bugs - TOFIX
---------------

>> 14Jan2012 <<

The code to execute which is copied to kmalloced location, doesn't seem to be flushed
to memory successfully always. This is also one serious issue affecting my kexec working
currently. Have to look at cache flushing kernel function which I have used properly
tomorrow and if required replace it or, have to move the code to copy to final location
in my code in innermost kexec after it disables interrupts and calls DSB and ISB (just to
be safe, even thou DSB and ISB doesn't seem to be helping here).

Also the patch to the kernel module by insmod support logic in kernel to resolve the
external symbols used in the module itself seems to be NOT fully flushed back into memory
from cache sometimes.



MISC
---------------

>> 12Jan2012 <<

***N*** Omap3 Bootrom
0x40014000 - start of BootRom
0x40014040 - Start Addr saved ?
0x40014044 - Boot message structure


>> 13Jan2012 <<

***N*** Omap3730 linux kernel after proc_fin and setup_mm_for_reboot

**** SCTLR
IF
	MRC p15, 0, <Rt>, c1, c0, 0
THEN
	Rt = 0x10c52c79 (QEmu-BeagleXM)
	Rt = 0x10c52c79 (NookTab)
	Rt = 0x10C52879 (BeaglXM)

